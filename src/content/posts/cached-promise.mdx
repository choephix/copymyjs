---
title: 'Promise Caching'
publishDate: '2024-03-21'
description: 'Cache and reuse promises for efficient resource loading'
draft: true
category: 'helpers'
version: 1
---

import CodeSnippet from '@/components/CodeSnippet.astro';
import Example from '@/components/Example.astro';

# Cached Promise

When loading resources or making API calls, it's common to need the same data in multiple places. Promise caching helps avoid duplicate requests by storing and reusing the same promise. This pattern is particularly valuable for controlling expensive asynchronous operations, preventing redundant network calls, and managing shared resources efficiently.

## createCachedPromise()

<CodeSnippet file="cached-promise/createCachedPromise.ts" />

## createResettableCachedPromise()

<CodeSnippet file="cached-promise/createResettableCachedPromise.ts" />

### Live Example

Try loading data multiple times to see how the same promise is reused:

<Example component="cached-promise-example" />

## Use Cases

1. **Data Fetching in Front-End Applications**
   ```typescript
   const loadUserProfile = createCachedPromise(() => 
     api.get('/user/profile')
   );

   // Multiple components can safely request the profile
   // Only one API call will be made
   function ProfileHeader() {
     const [profile, setProfile] = useState(null);
     useEffect(() => {
       loadUserProfile().then(setProfile);
     }, []);
     // ...
   }

   function Settings() {
     const [profile, setProfile] = useState(null);
     useEffect(() => {
       loadUserProfile().then(setProfile); // Reuses the same promise
     }, []);
     // ...
   }
   ```

2. **Server-Side Initialization**
   ```typescript
   const initializeDatabase = createCachedPromise(async () => {
     const connection = await createConnection(config);
     await runMigrations();
     return connection;
   });

   // Used across different routes/handlers
   app.get('/api/*', async (req, res, next) => {
     const db = await initializeDatabase(); // Connects once, reuses connection
     // ... handle request
   });
   ```

3. **Configuration and Feature Flags**
   ```typescript
   const loadFeatureFlags = createResettableCachedPromise(async () => {
     const response = await fetch('/api/feature-flags');
     return response.json();
   });

   // Reset cache periodically to fetch fresh flags
   setInterval(() => {
     loadFeatureFlags.reset();
   }, 5 * 60 * 1000); // Every 5 minutes
   ```

4. **Heavy Computation Memoization**
   ```typescript
   const generateReport = createCachedPromise(async () => {
     const data = await fetchLargeDataset();
     return processComplexCalculations(data);
   });

   // Multiple components can request the report
   // Calculation happens only once
   const result = await generateReport();
   ```

## Benefits and Considerations

1. **Race Condition Prevention**
   - Eliminates multiple simultaneous requests for the same resource
   - Ensures consistent state across the application
   - Reduces server load and network traffic

2. **Resource Optimization**
   - Prevents redundant API calls and database connections
   - Reduces CPU usage for expensive computations
   - Improves application performance and response times

3. **Implementation Considerations**
   - Consider cache invalidation strategies
   - Handle error cases appropriately
   - Implement timeouts for long-running operations

## Best Practices

1. **Cache Invalidation**
   - Use resettable version when data might change
   - Consider implementing TTL for time-sensitive data
   - Clear cache on relevant state changes

2. **Error Handling**
   - Handle rejected promises appropriately
   - Consider implementing retry logic
   - Clear cache on certain types of errors

3. **Memory Management**
   - Clear unused caches
   - Consider weak references for object caches
   - Implement cache size limits for large data

## Advanced Patterns

### With Timeout

```typescript
function createTimedCachedPromise<T>(
  fn: () => Promise<T>,
  ttlMs: number
) {
  let cachedPromise: Promise<T> | null = null;
  let expireTimeout: ReturnType<typeof setTimeout>;

  return () => {
    if (!cachedPromise) {
      cachedPromise = fn();
      expireTimeout = setTimeout(() => {
        cachedPromise = null;
      }, ttlMs);
    }
    return cachedPromise;
  };
}
```

### With Retry Logic

```typescript
function createRetryingCachedPromise<T>(
  fn: () => Promise<T>,
  maxRetries = 3
) {
  let cachedPromise: Promise<T> | null = null;
  let attempts = 0;

  const execute = async () => {
    try {
      return await fn();
    } catch (error) {
      if (attempts < maxRetries) {
        attempts++;
        cachedPromise = null;
        return execute();
      }
      throw error;
    }
  };

  return () => {
    if (!cachedPromise) {
      attempts = 0;
      cachedPromise = execute();
    }
    return cachedPromise;
  };
}
```
