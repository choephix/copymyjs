---
title: 'Custom Awaitable'
publishDate: '2024-03-21'
description: 'Create externally controllable Promise-like objects'
draft: true
category: 'helpers'
version: 1
---

import CodeSnippet from '@/components/CodeSnippet.astro';
import Example from '@/components/Example.astro';

# Custom Awaitable

A utility that creates Promise-like objects that can be resolved or rejected from outside their execution context. This is particularly useful for creating complex async flows, implementing cancellation patterns, or bridging between event-based and Promise-based code.

## Implementation

<CodeSnippet file="thenable/custom-awaitable.ts" />

## Live Example

Try out the custom awaitable with this interactive example:

<Example component="custom-awaitable-example" />

## Key Features

- **Promise Compatible**: Works with async/await and Promise chains
- **External Control**: Resolve or reject from anywhere
- **Type Safe**: Full TypeScript support
- **Standard Methods**: Includes then, catch, and finally
- **Thenable Interface**: Compatible with Promise.all and other Promise utilities

## Usage Examples

### Basic Usage

```typescript
const awaitable = createCustomAwaitable<string>();

// Use it like a promise
async function waitForValue() {
  try {
    const value = await awaitable;
    console.log('Received:', value);
  } catch (error) {
    console.error('Failed:', error);
  }
}

// Resolve or reject externally
setTimeout(() => awaitable.resolve('Hello!'), 1000);
```

### Event to Promise

```typescript
function eventToPromise(element: HTMLElement, eventName: string) {
  const awaitable = createCustomAwaitable<Event>();
  
  const handler = (e: Event) => {
    awaitable.resolve(e);
    element.removeEventListener(eventName, handler);
  };
  
  element.addEventListener(eventName, handler);
  return awaitable;
}

// Usage
const button = document.querySelector('button')!;
await eventToPromise(button, 'click');
console.log('Button clicked!');
```

### Cancellation Pattern

```typescript
function createCancellableOperation() {
  const awaitable = createCustomAwaitable<void>();
  let cancelled = false;

  async function run() {
    try {
      // Do some work
      if (cancelled) {
        awaitable.reject(new Error('Operation cancelled'));
        return;
      }
      awaitable.resolve();
    } catch (error) {
      awaitable.reject(error);
    }
  }

  return {
    promise: awaitable,
    cancel: () => {
      cancelled = true;
    }
  };
}
```

## Best Practices

1. **Clear Ownership**
   ```typescript
   class AsyncOperation {
     private readonly awaitable = createCustomAwaitable<Result>();
     
     start() {
       return this.awaitable;
     }
     
     private complete(result: Result) {
       this.awaitable.resolve(result);
     }
   }
   ```

2. **Error Handling**
   ```typescript
   const awaitable = createCustomAwaitable<Data>();
   
   try {
     const data = await fetchData();
     awaitable.resolve(data);
   } catch (error) {
     awaitable.reject(error);
   }
   ```

3. **Cleanup**
   ```typescript
   function createCleanupAwaitable() {
     const awaitable = createCustomAwaitable<void>();
     
     return {
       ...awaitable,
       cleanup: () => {
         try {
           // Cleanup logic
           awaitable.resolve();
         } catch (error) {
           awaitable.reject(error);
         }
       }
     };
   }
   ```

## Common Use Cases

1. **Resource Loading**
   - Image loading
   - Script loading
   - Font loading

2. **User Interaction**
   - Modal confirmations
   - Form submissions
   - User gestures

3. **State Management**
   - Loading states
   - Operation completion
   - Process synchronization

4. **Event Systems**
   - Event to Promise conversion
   - Message handling
   - WebSocket operations

## Advanced Patterns

### Timeout Wrapper

```typescript
function withTimeout<T>(awaitable: ReturnType<typeof createCustomAwaitable<T>>, ms: number) {
  const timeout = new Promise((_, reject) => {
    setTimeout(() => reject(new Error('Timeout')), ms);
  });
  
  return Promise.race([awaitable, timeout]);
}
```

### State Machine

```typescript
class StateMachine {
  private currentState = createCustomAwaitable<string>();
  
  async transition(to: string) {
    await this.currentState;
    this.currentState = createCustomAwaitable<string>();
    // Perform transition
    this.currentState.resolve(to);
  }
  
  waitForState(state: string) {
    return this.currentState.then(s => s === state);
  }
}
```

### Async Queue

```typescript
class AsyncQueue<T> {
  private current = createCustomAwaitable<T>();
  
  enqueue(item: T) {
    const previous = this.current;
    this.current = createCustomAwaitable<T>();
    previous.resolve(item);
  }
  
  async *[Symbol.asyncIterator]() {
    while (true) {
      yield await this.current;
    }
  }
} 
