---
title: "MultipleReasons: Advanced State Management"
publishDate: "2024-03-21"
description: "A powerful utility for managing multiple state conditions"
draft: true
category: "helpers"
version: 1
---

import CodeSnippet from '@/components/CodeSnippet.astro';
import Example from '@/components/Example.astro';

# MultipleReasons: Advanced State Management

The MultipleReasons utility provides a powerful way to manage multiple conditions that affect a single state. It's particularly useful for handling complex loading states, button disabling conditions, or any situation where multiple factors can influence a single outcome.

## Implementation

<CodeSnippet file="many-reasons.ts" />

## Live Example

Try out MultipleReasons with these interactive examples:

<Example component="many-reasons-example" />

## Key Features

- **Multiple Conditions**: Track multiple reasons for a state
- **Event-Based**: Built on EventBus for reactive updates
- **Async Support**: Handle async operations with `addDuring`
- **Hierarchical**: Support for parent-child relationships
- **Type-Safe**: Full TypeScript support

## Usage Examples

### Loading States

```typescript
const loadingReasons = new MultipleReasons();

async function loadData() {
  // Add a reason and get cleanup function
  const cleanup = loadingReasons.add('Loading data...');
  try {
    await fetchData();
  } finally {
    // Remove the reason when done
    cleanup();
  }
}

// Alternative using addDuring
async function loadImages() {
  const promise = fetchImages();
  loadingReasons.addDuring('Loading images...', promise);
  await promise;
}

// React to changes
loadingReasons.on({
  change: (hasReasons) => {
    showLoadingSpinner(hasReasons);
    console.log('Current reasons:', loadingReasons.toString());
  }
});
```

### Button States

```typescript
const submitReasons = new MultipleReasons();

// Disable button when there are any reasons
submitReasons.on({
  change: (hasReasons) => {
    submitButton.disabled = hasReasons;
  }
});

// Add/remove reasons based on conditions
function validateForm() {
  submitReasons.set('invalidEmail', !isEmailValid());
  submitReasons.set('passwordMismatch', !doPasswordsMatch());
}

// Check if submission is allowed
function canSubmit() {
  return !submitReasons.hasAny();
}
```

### Hierarchical States

```typescript
const globalLoadingReasons = new MultipleReasons();
const userLoadingReasons = new MultipleReasons();
const profileLoadingReasons = new MultipleReasons();

// Make global loading affect all child loaders
globalLoadingReasons.makeParentTo(
  userLoadingReasons,
  profileLoadingReasons
);

// Now when globalLoadingReasons has any reasons,
// all children will also show as having reasons
```

## Best Practices

1. **Use Descriptive Identifiers**
   ```typescript
   reasons.add('fetchingUserData');  // Good
   reasons.add('loading');           // Too vague
   ```

2. **Clean Up Properly**
   ```typescript
   class Component {
     private reasons = new MultipleReasons();
     private cleanup: (() => void)[] = [];

     init() {
       // Store cleanup functions
       this.cleanup.push(
         this.reasons.add('initializing')
       );
     }

     destroy() {
       // Clean up all reasons
       this.cleanup.forEach(fn => fn());
     }
   }
   ```

3. **Use with Async Operations**
   ```typescript
   async function loadData() {
     return reasons.addDuring(
       'loadingData',
       fetch('/api/data')
     );
   }
   ```

## Common Use Cases

1. **Loading States**
   - Multiple concurrent API calls
   - Resource loading (images, scripts)
   - Initialization processes

2. **Form Validation**
   - Multiple validation rules
   - Async validation
   - Cross-field validation

3. **Permission Systems**
   - Multiple permission requirements
   - Role-based access
   - Feature flags

4. **UI States**
   - Modal stacks
   - Navigation guards
   - Multi-step processes

## Advanced Patterns

### Combining with URL Parameters

```typescript
const reasons = new MultipleReasons();
const params = createUrlParamsProxy({ modal: false });

reasons.on({
  change: (hasReasons) => {
    params.modal = hasReasons;
  }
});
```

### Type-Safe Reason Keys

```typescript
const enum LoadingReason {
  UserData = 'userData',
  Settings = 'settings',
  Profile = 'profile'
}

const reasons = new MultipleReasons();
reasons.add(LoadingReason.UserData);
```

### Waiting for Multiple Conditions

```typescript
async function initializeApp() {
  const startup = new MultipleReasons();
  
  // Add initial reasons
  startup.add('configLoading');
  startup.add('userLoading');
  
  // Load in parallel
  await Promise.all([
    loadConfig().then(() => startup.remove('configLoading')),
    loadUser().then(() => startup.remove('userLoading'))
  ]);
  
  // Wait until everything is ready
  await startup.waitUntilEmpty();
  console.log('App ready!');
}
```
