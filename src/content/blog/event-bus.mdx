---
title: "Type-Safe Event Bus"
publishDate: "2024-03-21"
description: "A powerful, type-safe event bus implementation for TypeScript"
draft: false
category: "helpers"
version: 1
---

import CodeSnippet from '../../components/CodeSnippet.astro';
import Example from '../../components/Example.astro';

# Type-Safe Event Bus

A robust event bus implementation with full TypeScript support, allowing for type-safe event dispatching and handling.

## Implementation

<CodeSnippet file="event-bus.ts" />

## Live Example

Try out the event bus with a simple application flow:

<Example component="event-bus-example" />

## Key Features

- **Full Type Safety**: Events and their handlers are fully typed
- **Multiple Listeners**: Support for multiple listeners per event
- **Async Support**: Handles both sync and async event handlers
- **Promise Integration**: `waitFor` method for promise-based event handling
- **Cleanup Utilities**: Easy listener cleanup with returned functions
- **Context Binding**: Optional `this` parameter for event handlers

## Usage Examples

### Basic Usage

```typescript
type AppEvents = {
  'userLogin': (userId: string) => void;
  'notification': (message: string, type: 'info' | 'error') => void;
};

const bus = new EventBus<AppEvents>();

// Add listeners
bus.on({
  userLogin: (userId) => console.log(`User ${userId} logged in`),
  notification: (message, type) => showNotification(message, type)
});

// Dispatch events
bus.dispatch('userLogin', 'user123');
bus.dispatch('notification', 'Welcome back!', 'info');
```

### Async Event Handling

```typescript
type AsyncEvents = {
  'dataLoad': () => Promise<void>;
  'save': (data: any) => Promise<void>;
};

const bus = new EventBus<AsyncEvents>();

bus.on({
  dataLoad: async () => {
    const data = await fetchData();
    updateUI(data);
  }
});

// Async dispatch
await bus.dispatch('dataLoad');
```

### Using waitFor

```typescript
const bus = new EventBus<{
  'ready': () => void;
}>();

async function initApp() {
  // Wait for ready event
  await bus.waitFor('ready');
  console.log('App is ready!');
}

// Later...
bus.dispatch('ready');
```

## Best Practices

1. **Define Event Types**
   ```typescript
   // Create an enum or const object for event names
   const AppEvents = {
     LOGIN: 'login',
     LOGOUT: 'logout'
   } as const;
   
   // Use it in your event type
   type Events = {
     [AppEvents.LOGIN]: (user: User) => void;
     [AppEvents.LOGOUT]: () => void;
   };
   ```

2. **Cleanup Listeners**
   ```typescript
   class Component {
     private cleanup: (() => void)[] = [];

     init() {
       // Store cleanup function
       this.cleanup.push(bus.on({
         'event': this.handler
       }));
     }

     destroy() {
       // Clean up all listeners
       this.cleanup.forEach(fn => fn());
     }
   }
   ```

3. **Group Related Events**
   ```typescript
   type UserEvents = {
     'user:login': () => void;
     'user:logout': () => void;
     'user:update': () => void;
   };

   type UIEvents = {
     'ui:theme': () => void;
     'ui:resize': () => void;
   };

   type AppEvents = UserEvents & UIEvents;
   ```

## Common Use Cases

1. **Application State Management**
   - User authentication events
   - Theme changes
   - Global notifications

2. **Component Communication**
   - Cross-component updates
   - Parent-child communication
   - Sibling component interaction

3. **Plugin Systems**
   - Plugin initialization
   - Feature toggling
   - Extension point handling

4. **Analytics and Tracking**
   - User action tracking
   - Error logging
   - Performance monitoring